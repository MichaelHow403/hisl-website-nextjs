{"version":3,"file":"../app/_not-found/page.js","mappings":"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,IAAiE,CAAxC,CAAwC,IAAH,GAAG,KAAoB,oCACrF,EADmK,CAAoD,SACvN,EACA,yBACA,WACA,wBACA,0BACA,2BACA,2BACA,2BACA,+BACA,uBACA,6BACA,qCACA,mCACA,8DACA,+CACA,oBAjO+B,EAkO/B,GAlOuE,cAkOjC,oBAAc,uBACpD,4CACA,qBACA,4CACA,OACA,cACA,2BACA,sBACA,gBACA,yBACA,EAAsB,EAAI,CAC1B,cACA,qBACA,yBACA,sCACA,kDACA,wDACA,wDACA,gDACA,sCACA,gDACA,2DACA,CAAqB,CACrB,sBACA,YACA,eACA,CAAqB,CACrB,uBAA4C,CAC5C,kEACA,IAAyB,oBAAc,kBACvC,YAEA,EACA,eACA,CAAoB,YAAW,EAC/B,cAAoB,cAA0B,CAC9C,aAAmC,EAUnC,GATA,GACA,GAAwB,wBAAsB,KAI9C,8BAIA,sDACA,0BACA,gFAA8G,GAAiB,EAAE,4CAAoF,cAA8B,KAAO;AAAA,kGAC1P,aACA,cACA,eACA,CAAiB,EACjB,2BACA,aACA,+CACA,CACA,OACA,CACA,OACA,OACA,KAA0B,iBAAe,UACzC,OACA,UACA,qBACA,sBACA,oBACA,0BACiB,CACjB,cACA,CACA,EACA,qBAA2C,+CAAuD,IAClG,IAaA,EAbA,eACA,qBAGA,kBAOA,MANA,+BACA,yBAEA,iBACA,uCAEA,KAuBA,GApBA,IACA,GAA+B,wBAAkB,eAKjD,IAAiC,cAAY,YAAc,WAAK,MAChE,WACA,GAAmC,cAAY,yBAG/C,iCACA,QAKA,SAA0D,cAAY,gBACtE,GAA+B,cAAY,yBAE3C,QAAiD,cAAY,sDAS7D,EANA,GAEA,SACA,IAAiC,cAAY,WAC7C,UAA8B,iBAAe,CAG7C,YACA,0EAwBA,GArBA,0BACA,WACA,MACA,cACA,UAAmC,WAAS,UAC5C,cACA,oBACA,qBACA,8BACA,OAGA,iBACA,oBAGA,MAAuE,OAAsB,SAC7F,CAA6B,EAC7B,sBACqB,EAErB,qBAEA,KAIA,OADA,sBACA,CAEA,CACA,CAGA,2BAGA,kBACA,OACA,cACA,aACA,aACA,CAAqB,CACrB,OACA,KAA8B,iBAAe,OAC7C,KAA8B,SAAY,OAC1C,WAAoC,CACpC,eACA,aACA,CACA,EAKA,cAA+E,oBAAc,+BAAwD,OAAsB,UAE3K,UACA,OACA,YACA,qBACA,CAAa,CACb,EACA,gBACA,IAsCA,EAsDA,EAsBA,MArDA,EA5DA,0BACA,YACA,wBACA,OACA,KACqB,EACrB,UAA2B,WAAS,UACpC,wBACA,qBACA,MACA,cACA,oBACA,sBACa,EAQb,GAPA,GACA,uFAGA,SACA,yDAEA,IACA,MAMA,4GACA,YACA,cACA,eACA,CAAqB,EAErB,WACA,CACA,uCAAuG,iBAAe,UAEtH,6FAAiH,gCAAmF,wBACpM,aACA,cACA,eACA,CAAiB,EAEjB,yCACA,IAGA,gBACA,GAGA,uFAIA,YAA8B,0BAAwB,OAEtD,IAAoB,SAAoB,EAKxC,MACA,GACA,aACA,aACA,OACc,kBACd,GACA,aACA,aACA,OACc,YAEd,KACA,GACA,aACA,aACA,OACkB,MAOA,mBAGlB,+CAEA,+BACA,gFAAgH,2BAAoC,2BACpJ,YACA,cACA,eACA,CAA6B,EAE7B,GACA,qCACA,iEAEA,EAAsB,IACtB,GACA,WAAwC,gBAAc,CACtD,aACA,CAEA,MA5BA,8BACA,IACA,aACA,aACA,GA2BA,GADA,iBACA,+CAAiH,iBAAe,0BAWhI,YAA8B,0BAAwB,MAGtD,mCAAiH,wBAAsB,EACvI,8BACA,YAAkC,wBAAsB,IAExD,mCACA,WAE2B,sBAAgB,EAC3C,MACA,MACA,+BACA,mCACA,OAAgC,SAAY,cAA4B,yBAAuB,EAC/F,2BACA,CAAqB,GAQrB,iBACuB,sBAAgB,EACvC,MACA,MACA,+BACA,mCACA,OAA4B,SAAY,OACxC,4BACiB,EACjB,CAGA,MAAiC,oBAAc,mBAC/C,MACA,SACA,KAGA,OACA,WACA,WACA,CACA,CAAiB,EACjB,IAAyB,oBAAc,aACvC,CAAiB,EAGjB,YAKA,SACA,+HACA,aACA,cACA,eACA,CAAiB,EAEjB,cACA,OACA,YACA,EAIA,eAHA,OACA,SAAmC,wBAAsB,EAEzD,mBACA,cACA,oBACA,eACA,wBAEsB,oBACtB,iBAGA,mBAGA,CAGA,mCAA2G,wBAAsB,EAsBjI,GArBA,8BACA,YAA8B,wBAAsB,IAKpD,mBACA,wBAGA,cAAqD,oBAAkB,gBACvE,mBAGA,GACA,YAA8B,0BAAwB,MAMtD,QAEA,uBACA,eACA,wGACA,aACA,cACA,eACA,CAAyB,EAEzB,MAA2B,sBAAgB,EAC3C,MACA,MACA,+BACA,mCACA,cAMA,iBACA,aACA,aACA,EAA0B,eACL,CACrB,CAGA,MAAuB,sBAAgB,EACvC,MACA,MACA,+BACA,mCACA,OAA4B,SAAY,sBAAgC,yBAAuB,EAC/F,4BACiB,CACjB,CAEA,aAIA,aAUA,MAAuB,sBAAgB,EACvC,MACA,MACA,+BACA,mCACA,SACA,4BACiB,EAMjB,MASA,OANA,2BACA,SACA,UAA2C,cAAY,uBACvD,SACA,CACA,CAAiB,GACM,sBAAgB,EACvC,MACA,MACA,+BACA,mCACA,SACA,cACA,aACA,aACA,CACA,CAAiB,EAWjB,0BAqCA,OApCA,mBAIA,GACA,OACA,sBAGA,wBACA,CAAa,qBACb,EASA,EARA,MACA,sGACA,aACA,cACA,eACA,CAAqB,EAErB,uCAA+F,iBAAe,UAE9G,8EAAsG,gCAAuE,wBAC7K,aACA,cACA,eACA,CAAqB,CAGrB,sCACA,CAAa,YAGb,8BACA,6CACA,CAAiB,CACjB,CAAa,EACM,sBAAgB,EACnC,MACA,MACA,+BACA,mCACA,SAIA,cACA,aACA,aACA,CACA,CAAa,CACb,EAGA,OAGA,6DAAoF,gBAAc,gBAClG,YAAiC,IAAQ,EAAE,MAAQ,EACnD,KAA0B,UAAQ,QAClC,YACA,iBACA,oBAEA,CAAiB,IATjB,YAWA,CAAM,SAcN,MAZA,iBAA4C,iBAAe,EAC3D,4BACA,wBACA,YACA,mBACA,iBAAkC,OAAmB,EACrD,gBACA,uBACA,CAAiB,CACjB,CAAa,KAGb,CACA,CACA","sources":["webpack://hisl-nextjs/external commonjs \"next/dist/shared/lib/router/utils/app-paths\"","webpack://hisl-nextjs/external commonjs \"next/dist/server/app-render/after-task-async-storage.external.js\"","webpack://hisl-nextjs/external commonjs2 \"module\"","webpack://hisl-nextjs/external commonjs \"next/dist/compiled/next-server/app-page.runtime.prod.js\"","webpack://hisl-nextjs/src/app/layout.tsx","webpack://hisl-nextjs/sentry-wrapper-module","webpack://hisl-nextjs/external commonjs \"require-in-the-middle\"","webpack://hisl-nextjs/external commonjs \"next/dist/server/app-render/action-async-storage.external.js\"","webpack://hisl-nextjs/external commonjs2 \"process\"","webpack://hisl-nextjs/external commonjs2 \"os\"","webpack://hisl-nextjs/external commonjs \"next/dist/shared/lib/router/utils/is-bot\"","webpack://hisl-nextjs/?bf91","webpack://hisl-nextjs/external commonjs2 \"util\"","webpack://hisl-nextjs/external commonjs2 \"fs\"","webpack://hisl-nextjs/external commonjs \"next/dist/server/app-render/work-async-storage.external.js\"","webpack://hisl-nextjs/external node-commonjs \"node:child_process\"","webpack://hisl-nextjs/?268f","webpack://hisl-nextjs/external commonjs2 \"path\"","webpack://hisl-nextjs/external commonjs2 \"diagnostics_channel\"","webpack://hisl-nextjs/external node-commonjs \"node:http\"","webpack://hisl-nextjs/external node-commonjs \"node:zlib\"","webpack://hisl-nextjs/external commonjs \"next/dist/server/app-render/dynamic-access-async-storage.external.js\"","webpack://hisl-nextjs/external node-commonjs \"node:tls\"","webpack://hisl-nextjs/external node-commonjs \"node:https\"","webpack://hisl-nextjs/./node_modules/@opentelemetry/instrumentation/build/esm/platform/node/ sync","webpack://hisl-nextjs/external node-commonjs \"node:os\"","webpack://hisl-nextjs/external node-commonjs \"node:diagnostics_channel\"","webpack://hisl-nextjs/external commonjs2 \"crypto\"","webpack://hisl-nextjs/external commonjs \"import-in-the-middle\"","webpack://hisl-nextjs/external node-commonjs \"node:stream\"","webpack://hisl-nextjs/external node-commonjs \"node:util\"","webpack://hisl-nextjs/./src/app/globals.css","webpack://hisl-nextjs/./node_modules/@prisma/instrumentation/node_modules/@opentelemetry/instrumentation/build/esm/platform/node/ sync","webpack://hisl-nextjs/external commonjs \"next/dist/server/app-render/work-unit-async-storage.external.js\"","webpack://hisl-nextjs/./src/app/favicon.ico","webpack://hisl-nextjs/external node-commonjs \"node:fs\"","webpack://hisl-nextjs/external commonjs2 \"worker_threads\"","webpack://hisl-nextjs/external commonjs2 \"perf_hooks\"","webpack://hisl-nextjs/external node-commonjs \"node:worker_threads\"","webpack://hisl-nextjs/external node-commonjs \"node:path\"","webpack://hisl-nextjs/external node-commonjs \"node:net\"","webpack://hisl-nextjs/external commonjs2 \"url\"","webpack://hisl-nextjs/external commonjs2 \"child_process\"","webpack://hisl-nextjs/external node-commonjs \"node:readline\"","webpack://hisl-nextjs/external commonjs2 \"tty\"","webpack://hisl-nextjs/external commonjs2 \"async_hooks\"","webpack://hisl-nextjs/external commonjs \"next/dist/shared/lib/no-fallback-error.external\"","webpack://hisl-nextjs/external node-commonjs \"node:inspector\"","webpack://hisl-nextjs/?261c","webpack://hisl-nextjs/external commonjs2 \"events\"","webpack://hisl-nextjs/?85fb","webpack://hisl-nextjs/?92e4"],"sourcesContent":["module.exports = require(\"next/dist/shared/lib/router/utils/app-paths\");","module.exports = require(\"next/dist/server/app-render/after-task-async-storage.external.js\");","module.exports = require(\"module\");","module.exports = require(\"next/dist/compiled/next-server/app-page.runtime.prod.js\");","import type { Metadata } from \"next\";\nimport { Geist, Geist_Mono } from \"next/font/google\";\nimport \"./globals.css\";\n\nconst geistSans = Geist({\n  variable: \"--font-geist-sans\",\n  subsets: [\"latin\"],\n});\n\nconst geistMono = Geist_Mono({\n  variable: \"--font-geist-mono\",\n  subsets: [\"latin\"],\n});\n\nexport const metadata: Metadata = {\n  title: \"HISL - Construction Safety AI & Management Consultancy\",\n  description: \"HISL delivers advanced construction safety AI solutions and project management consultancy. Expert construction management with cutting-edge artificial intelligence for safer, more efficient building projects.\",\n  keywords: \"construction safety AI, construction management, project management consultancy, construction safety, AI construction, building safety technology, construction consulting, MCIOB, construction AI solutions\",\n  authors: [{ name: \"Michael Howard\", url: \"https://hisl.ie\" }, { name: \"HISL Team\" }],\n  creator: \"Michael Howard - Chartered Construction Manager\",\n  publisher: \"HISL - Human Intelligence Systems Laboratory\",\n  robots: \"index, follow\",\n  metadataBase: new URL('https://hisl.ie'),\n  alternates: {\n    canonical: '/',\n  },\n  openGraph: {\n    title: \"HISL - Construction Safety AI & Management Consultancy\",\n    description: \"Expert construction management consultancy with cutting-edge AI solutions for safer, more efficient building projects. Led by Michael Howard, Chartered Construction Manager.\",\n    type: \"website\",\n    url: \"https://hisl.ie\",\n    siteName: \"HISL\",\n    locale: \"en_IE\",\n    images: [\n      {\n        url: \"/imagery/processed/general/ai_construction_bridge-1200w.webp\",\n        width: 1200,\n        height: 800,\n        alt: \"HISL Construction AI - Advanced building safety technology\",\n      },\n      {\n        url: \"/imagery/processed/earth/earth_daymap-1200w.webp\", \n        width: 1200,\n        height: 1200,\n        alt: \"HISL Global Construction Solutions\",\n      }\n    ],\n  },\n  twitter: {\n    card: \"summary_large_image\",\n    title: \"HISL - Construction Safety AI & Management Consultancy\",\n    description: \"Expert construction management with cutting-edge AI solutions for safer building projects.\",\n    images: [\"/imagery/processed/general/ai_construction_bridge-1200w.webp\"],\n  },\n  other: {\n    'application-name': 'HISL',\n    'msapplication-TileColor': '#D9A441',\n    'theme-color': '#D9A441',\n  }\n};\n\nexport default function RootLayout({\n  children,\n}: Readonly<{\n  children: React.ReactNode;\n}>) {\n  return (\n    <html lang=\"en\">\n      <head>\n        <script\n          type=\"application/ld+json\"\n          dangerouslySetInnerHTML={{\n            __html: JSON.stringify({\n              \"@context\": \"https://schema.org\",\n              \"@type\": \"Organization\",\n              \"name\": \"HISL - Human Intelligence Systems Laboratory\",\n              \"legalName\": \"Human Intelligence Systems Laboratory\",\n              \"url\": \"https://hisl.ie\",\n              \"logo\": \"https://hisl.ie/images/HISL_Logo.jpeg\",\n              \"description\": \"Construction Safety AI & Management Consultancy delivering advanced AI solutions for safer, more efficient building projects.\",\n              \"founder\": {\n                \"@type\": \"Person\",\n                \"name\": \"Michael Howard\",\n                \"jobTitle\": \"Chartered Construction Manager\",\n                \"memberOf\": \"MCIOB\"\n              },\n              \"industry\": [\"Construction Management\", \"Artificial Intelligence\", \"Safety Technology\"],\n              \"serviceArea\": {\n                \"@type\": \"Country\",\n                \"name\": \"Ireland\"\n              },\n              \"hasOfferCatalog\": {\n                \"@type\": \"OfferCatalog\",\n                \"name\": \"Construction AI Services\",\n                \"itemListElement\": [\n                  {\n                    \"@type\": \"Offer\",\n                    \"itemOffered\": {\n                      \"@type\": \"Service\",\n                      \"name\": \"Construction Safety AI Solutions\",\n                      \"description\": \"AI-powered construction safety monitoring and risk assessment\"\n                    }\n                  },\n                  {\n                    \"@type\": \"Offer\",\n                    \"itemOffered\": {\n                      \"@type\": \"Service\", \n                      \"name\": \"Project Management Consultancy\",\n                      \"description\": \"Expert construction project management and consulting services\"\n                    }\n                  }\n                ]\n              },\n              \"contactPoint\": {\n                \"@type\": \"ContactPoint\",\n                \"url\": \"https://hisl.ie/contact\",\n                \"contactType\": \"Business\"\n              }\n            })\n          }}\n        />\n      </head>\n      <body\n        className={`${geistSans.variable} ${geistMono.variable} antialiased`}\n      >\n        {children}\n      </body>\n    </html>\n  );\n}\n","import * as origModule from 'next/dist/server/app-render/work-unit-async-storage.external.js';\nimport * as serverComponentModule from '__SENTRY_WRAPPING_TARGET_FILE__.cjs';\nexport * from '__SENTRY_WRAPPING_TARGET_FILE__.cjs';\nimport * as Sentry from '@sentry/nextjs';\n\n// @ts-expect-error Because we cannot be sure if the RequestAsyncStorage module exists (it is not part of the Next.js public\n// API) we use a shim if it doesn't exist. The logic for this is in the wrapping loader.\n\nconst asyncStorageModule = { ...origModule } ;\n\nconst requestAsyncStorage =\n  'workUnitAsyncStorage' in asyncStorageModule\n    ? asyncStorageModule.workUnitAsyncStorage\n    : 'requestAsyncStorage' in asyncStorageModule\n      ? asyncStorageModule.requestAsyncStorage\n      : undefined;\n\nconst serverComponent = serverComponentModule.default;\n\nlet wrappedServerComponent;\nif (typeof serverComponent === 'function') {\n  // For some odd Next.js magic reason, `headers()` will not work if used inside `wrapServerComponentsWithSentry`.\n  // Current assumption is that Next.js applies some loader magic to userfiles, but not files in node_modules. This file\n  // is technically a userfile so it gets the loader magic applied.\n  wrappedServerComponent = new Proxy(serverComponent, {\n    apply: (originalFunction, thisArg, args) => {\n      let sentryTraceHeader = undefined;\n      let baggageHeader = undefined;\n      let headers = undefined;\n\n      // We try-catch here just in `requestAsyncStorage` is undefined since it may not be defined\n      try {\n        const requestAsyncStore = requestAsyncStorage?.getStore() ;\n        sentryTraceHeader = requestAsyncStore?.headers.get('sentry-trace') ?? undefined;\n        baggageHeader = requestAsyncStore?.headers.get('baggage') ?? undefined;\n        headers = requestAsyncStore?.headers;\n      } catch {\n        /** empty */\n      }\n\n      return Sentry.wrapServerComponentWithSentry(originalFunction, {\n        componentRoute: '/',\n        componentType: 'Layout',\n        sentryTraceHeader,\n        baggageHeader,\n        headers,\n      }).apply(thisArg, args);\n    },\n  });\n} else {\n  wrappedServerComponent = serverComponent;\n}\n\nconst generateMetadata = serverComponentModule.generateMetadata\n  ? Sentry.wrapGenerationFunctionWithSentry(serverComponentModule.generateMetadata, {\n      componentRoute: '/',\n      componentType: 'Layout',\n      generationFunctionIdentifier: 'generateMetadata',\n      requestAsyncStorage,\n    })\n  : undefined;\n\nconst generateImageMetadata = serverComponentModule.generateImageMetadata\n  ? Sentry.wrapGenerationFunctionWithSentry(serverComponentModule.generateImageMetadata, {\n      componentRoute: '/',\n      componentType: 'Layout',\n      generationFunctionIdentifier: 'generateImageMetadata',\n      requestAsyncStorage,\n    })\n  : undefined;\n\nconst generateViewport = serverComponentModule.generateViewport\n  ? Sentry.wrapGenerationFunctionWithSentry(serverComponentModule.generateViewport, {\n      componentRoute: '/',\n      componentType: 'Layout',\n      generationFunctionIdentifier: 'generateViewport',\n      requestAsyncStorage,\n    })\n  : undefined;\n\nconst wrappedServerComponent$1 = wrappedServerComponent;\n\nexport { wrappedServerComponent$1 as default, generateImageMetadata, generateMetadata, generateViewport };\n","module.exports = require(\"require-in-the-middle\");","module.exports = require(\"next/dist/server/app-render/action-async-storage.external.js\");","module.exports = require(\"process\");","module.exports = require(\"os\");","module.exports = require(\"next/dist/shared/lib/router/utils/is-bot\");","import(/* webpackMode: \"eager\" */ \"/home/michael/projects/hisl-website-nextjs/node_modules/next/dist/client/components/builtin/global-error.js\");\n;\nimport(/* webpackMode: \"eager\" */ \"/home/michael/projects/hisl-website-nextjs/node_modules/next/dist/client/components/client-page.js\");\n;\nimport(/* webpackMode: \"eager\" */ \"/home/michael/projects/hisl-website-nextjs/node_modules/next/dist/client/components/client-segment.js\");\n;\nimport(/* webpackMode: \"eager\" */ \"/home/michael/projects/hisl-website-nextjs/node_modules/next/dist/client/components/http-access-fallback/error-boundary.js\");\n;\nimport(/* webpackMode: \"eager\" */ \"/home/michael/projects/hisl-website-nextjs/node_modules/next/dist/client/components/layout-router.js\");\n;\nimport(/* webpackMode: \"eager\" */ \"/home/michael/projects/hisl-website-nextjs/node_modules/next/dist/client/components/metadata/async-metadata.js\");\n;\nimport(/* webpackMode: \"eager\" */ \"/home/michael/projects/hisl-website-nextjs/node_modules/next/dist/client/components/render-from-template-context.js\");\n;\nimport(/* webpackMode: \"eager\" */ \"/home/michael/projects/hisl-website-nextjs/node_modules/next/dist/lib/framework/boundary-components.js\");\n;\nimport(/* webpackMode: \"eager\" */ \"/home/michael/projects/hisl-website-nextjs/node_modules/next/dist/lib/metadata/generate/icon-mark.js\");\n","module.exports = require(\"util\");","module.exports = require(\"fs\");","module.exports = require(\"next/dist/server/app-render/work-async-storage.external.js\");","module.exports = require(\"node:child_process\");",null,"module.exports = require(\"path\");","module.exports = require(\"diagnostics_channel\");","module.exports = require(\"node:http\");","module.exports = require(\"node:zlib\");","module.exports = require(\"next/dist/server/app-render/dynamic-access-async-storage.external.js\");","module.exports = require(\"node:tls\");","module.exports = require(\"node:https\");","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = 44725;\nmodule.exports = webpackEmptyContext;","module.exports = require(\"node:os\");","module.exports = require(\"node:diagnostics_channel\");","module.exports = require(\"crypto\");","module.exports = require(\"import-in-the-middle\");","module.exports = require(\"node:stream\");","module.exports = require(\"node:util\");",null,"function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = 62992;\nmodule.exports = webpackEmptyContext;","module.exports = require(\"next/dist/server/app-render/work-unit-async-storage.external.js\");","  import { fillMetadataSegment } from 'next/dist/lib/metadata/get-metadata-route'\n\n  export default async (props) => {\n    const imageData = {\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}\n    const imageUrl = fillMetadataSegment(\".\", await props.params, \"favicon.ico\")\n\n    return [{\n      ...imageData,\n      url: imageUrl + \"\",\n    }]\n  }","module.exports = require(\"node:fs\");","module.exports = require(\"worker_threads\");","module.exports = require(\"perf_hooks\");","module.exports = require(\"node:worker_threads\");","module.exports = require(\"node:path\");","module.exports = require(\"node:net\");","module.exports = require(\"url\");","module.exports = require(\"child_process\");","module.exports = require(\"node:readline\");","module.exports = require(\"tty\");","module.exports = require(\"async_hooks\");","module.exports = require(\"next/dist/shared/lib/no-fallback-error.external\");","module.exports = require(\"node:inspector\");","import(/* webpackMode: \"eager\" */ \"/home/michael/projects/hisl-website-nextjs/node_modules/next/dist/client/components/builtin/global-error.js\");\n;\nimport(/* webpackMode: \"eager\" */ \"/home/michael/projects/hisl-website-nextjs/node_modules/next/dist/client/components/client-page.js\");\n;\nimport(/* webpackMode: \"eager\" */ \"/home/michael/projects/hisl-website-nextjs/node_modules/next/dist/client/components/client-segment.js\");\n;\nimport(/* webpackMode: \"eager\" */ \"/home/michael/projects/hisl-website-nextjs/node_modules/next/dist/client/components/http-access-fallback/error-boundary.js\");\n;\nimport(/* webpackMode: \"eager\" */ \"/home/michael/projects/hisl-website-nextjs/node_modules/next/dist/client/components/layout-router.js\");\n;\nimport(/* webpackMode: \"eager\" */ \"/home/michael/projects/hisl-website-nextjs/node_modules/next/dist/client/components/metadata/async-metadata.js\");\n;\nimport(/* webpackMode: \"eager\" */ \"/home/michael/projects/hisl-website-nextjs/node_modules/next/dist/client/components/render-from-template-context.js\");\n;\nimport(/* webpackMode: \"eager\" */ \"/home/michael/projects/hisl-website-nextjs/node_modules/next/dist/lib/framework/boundary-components.js\");\n;\nimport(/* webpackMode: \"eager\" */ \"/home/michael/projects/hisl-website-nextjs/node_modules/next/dist/lib/metadata/generate/icon-mark.js\");\n","module.exports = require(\"events\");","const notFound0 = () => import(/* webpackMode: \"eager\" */ \"next/dist/client/components/builtin/not-found.js\");\nconst module1 = () => import(/* webpackMode: \"eager\" */ \"/home/michael/projects/hisl-website-nextjs/src/app/layout.tsx\");\nconst module2 = () => import(/* webpackMode: \"eager\" */ \"next/dist/client/components/builtin/global-error.js\");\nconst module3 = () => import(/* webpackMode: \"eager\" */ \"next/dist/client/components/builtin/forbidden.js\");\nconst module4 = () => import(/* webpackMode: \"eager\" */ \"next/dist/client/components/builtin/unauthorized.js\");\nimport { AppPageRouteModule } from \"next/dist/server/route-modules/app-page/module.compiled\" with {\n    'turbopack-transition': 'next-ssr'\n};\nimport { RouteKind } from \"next/dist/server/route-kind\" with {\n    'turbopack-transition': 'next-server-utility'\n};\nimport { getRevalidateReason } from \"next/dist/server/instrumentation/utils\";\nimport { getTracer, SpanKind } from \"next/dist/server/lib/trace/tracer\";\nimport { getRequestMeta } from \"next/dist/server/request-meta\";\nimport { BaseServerSpan } from \"next/dist/server/lib/trace/constants\";\nimport { interopDefault } from \"next/dist/server/app-render/interop-default\";\nimport { stripFlightHeaders } from \"next/dist/server/app-render/strip-flight-headers\";\nimport { NodeNextRequest, NodeNextResponse } from \"next/dist/server/base-http/node\";\nimport { checkIsAppPPREnabled } from \"next/dist/server/lib/experimental/ppr\";\nimport { getFallbackRouteParams } from \"next/dist/server/request/fallback-params\";\nimport { setReferenceManifestsSingleton } from \"next/dist/server/app-render/encryption-utils\";\nimport { isHtmlBotRequest, shouldServeStreamingMetadata } from \"next/dist/server/lib/streaming-metadata\";\nimport { createServerModuleMap } from \"next/dist/server/app-render/action-utils\";\nimport { normalizeAppPath } from \"next/dist/shared/lib/router/utils/app-paths\";\nimport { getIsPossibleServerAction } from \"next/dist/server/lib/server-action-request-meta\";\nimport { RSC_HEADER, NEXT_ROUTER_PREFETCH_HEADER, NEXT_IS_PRERENDER_HEADER, NEXT_DID_POSTPONE_HEADER, RSC_CONTENT_TYPE_HEADER } from \"next/dist/client/components/app-router-headers\";\nimport { getBotType, isBot } from \"next/dist/shared/lib/router/utils/is-bot\";\nimport { CachedRouteKind } from \"next/dist/server/response-cache\";\nimport { FallbackMode, parseFallbackField } from \"next/dist/lib/fallback\";\nimport RenderResult from \"next/dist/server/render-result\";\nimport { CACHE_ONE_YEAR, HTML_CONTENT_TYPE_HEADER, NEXT_CACHE_TAGS_HEADER } from \"next/dist/lib/constants\";\nimport { ENCODED_TAGS } from \"next/dist/server/stream-utils/encoded-tags\";\nimport { sendRenderResult } from \"next/dist/server/send-payload\";\nimport { NoFallbackError } from \"next/dist/shared/lib/no-fallback-error.external\";\n// We inject the tree and pages here so that we can use them in the route\n// module.\nconst tree = {\n        children: [\n        '',\n        {\n              children: [\"/_not-found\", {\n                children: ['__PAGE__', {}, {\n                  page: [\n                    notFound0,\n                    \"next/dist/client/components/builtin/not-found.js\"\n                  ]\n                }]\n              }, {}]\n            },\n        {\n        'layout': [module1, \"/home/michael/projects/hisl-website-nextjs/src/app/layout.tsx\"],\n'global-error': [module2, \"next/dist/client/components/builtin/global-error.js\"],\n'forbidden': [module3, \"next/dist/client/components/builtin/forbidden.js\"],\n'unauthorized': [module4, \"next/dist/client/components/builtin/unauthorized.js\"],\n        metadata: {\n    icon: [(async (props) => (await import(/* webpackMode: \"eager\" */ \"next-metadata-image-loader?type=favicon&segment=&basePath=&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js!/home/michael/projects/hisl-website-nextjs/src/app/favicon.ico?__next_metadata__\")).default(props))],\n    apple: [],\n    openGraph: [],\n    twitter: [],\n    manifest: undefined\n  }\n      }\n      ]\n      }.children;\nconst pages = [];\nexport { tree, pages };\nimport GlobalError from \"next/dist/client/components/builtin/global-error.js\" with {\n    'turbopack-transition': 'next-server-utility'\n};\nexport { GlobalError };\nconst __next_app_require__ = __webpack_require__\nconst __next_app_load_chunk__ = () => Promise.resolve()\nexport const __next_app__ = {\n    require: __next_app_require__,\n    loadChunk: __next_app_load_chunk__\n};\nimport * as entryBase from \"next/dist/server/app-render/entry-base\" with {\n    'turbopack-transition': 'next-server-utility'\n};\nimport { RedirectStatusCode } from \"next/dist/client/components/redirect-status-code\";\nexport * from \"next/dist/server/app-render/entry-base\" with {\n    'turbopack-transition': 'next-server-utility'\n};\n// Create and export the route module that will be consumed.\nexport const routeModule = new AppPageRouteModule({\n    definition: {\n        kind: RouteKind.APP_PAGE,\n        page: \"/_not-found/page\",\n        pathname: \"/_not-found\",\n        // The following aren't used in production.\n        bundlePath: '',\n        filename: '',\n        appPaths: []\n    },\n    userland: {\n        loaderTree: tree\n    },\n    distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n    relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || ''\n});\nexport async function handler(req, res, ctx) {\n    var _this;\n    let srcPage = \"/_not-found/page\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (process.env.TURBOPACK) {\n        srcPage = srcPage.replace(/\\/index$/, '') || '/';\n    } else if (srcPage === '/index') {\n        // we always normalize /index specifically\n        srcPage = '/';\n    }\n    const multiZoneDraftMode = process.env.__NEXT_MULTI_ZONE_DRAFT_MODE;\n    const initialPostponed = getRequestMeta(req, 'postponed');\n    // TODO: replace with more specific flags\n    const minimalMode = getRequestMeta(req, 'minimalMode');\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage,\n        multiZoneDraftMode\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return null;\n    }\n    const { buildId, query, params, parsedUrl, pageIsDynamic, buildManifest, nextFontManifest, reactLoadableManifest, serverActionsManifest, clientReferenceManifest, subresourceIntegrityManifest, prerenderManifest, isDraftMode, resolvedPathname, revalidateOnlyGenerated, routerServerContext, nextConfig, interceptionRoutePatterns } = prepareResult;\n    const pathname = parsedUrl.pathname || '/';\n    const normalizedSrcPage = normalizeAppPath(srcPage);\n    let { isOnDemandRevalidate } = prepareResult;\n    const prerenderInfo = routeModule.match(pathname, prerenderManifest);\n    const isPrerendered = !!prerenderManifest.routes[resolvedPathname];\n    let isSSG = Boolean(prerenderInfo || isPrerendered || prerenderManifest.routes[normalizedSrcPage]);\n    const userAgent = req.headers['user-agent'] || '';\n    const botType = getBotType(userAgent);\n    const isHtmlBot = isHtmlBotRequest(req);\n    /**\n   * If true, this indicates that the request being made is for an app\n   * prefetch request.\n   */ const isPrefetchRSCRequest = getRequestMeta(req, 'isPrefetchRSCRequest') ?? req.headers[NEXT_ROUTER_PREFETCH_HEADER] === '1' // exclude runtime prefetches, which use '2'\n    ;\n    // NOTE: Don't delete headers[RSC] yet, it still needs to be used in renderToHTML later\n    const isRSCRequest = getRequestMeta(req, 'isRSCRequest') ?? Boolean(req.headers[RSC_HEADER]);\n    const isPossibleServerAction = getIsPossibleServerAction(req);\n    /**\n   * If the route being rendered is an app page, and the ppr feature has been\n   * enabled, then the given route _could_ support PPR.\n   */ const couldSupportPPR = checkIsAppPPREnabled(nextConfig.experimental.ppr);\n    // When enabled, this will allow the use of the `?__nextppronly` query to\n    // enable debugging of the static shell.\n    const hasDebugStaticShellQuery = process.env.__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING === '1' && typeof query.__nextppronly !== 'undefined' && couldSupportPPR;\n    // When enabled, this will allow the use of the `?__nextppronly` query\n    // to enable debugging of the fallback shell.\n    const hasDebugFallbackShellQuery = hasDebugStaticShellQuery && query.__nextppronly === 'fallback';\n    // This page supports PPR if it is marked as being `PARTIALLY_STATIC` in the\n    // prerender manifest and this is an app page.\n    const isRoutePPREnabled = couldSupportPPR && (((_this = prerenderManifest.routes[normalizedSrcPage] ?? prerenderManifest.dynamicRoutes[normalizedSrcPage]) == null ? void 0 : _this.renderingMode) === 'PARTIALLY_STATIC' || // Ideally we'd want to check the appConfig to see if this page has PPR\n    // enabled or not, but that would require plumbing the appConfig through\n    // to the server during development. We assume that the page supports it\n    // but only during development.\n    hasDebugStaticShellQuery && (routeModule.isDev === true || (routerServerContext == null ? void 0 : routerServerContext.experimentalTestProxy) === true));\n    const isDebugStaticShell = hasDebugStaticShellQuery && isRoutePPREnabled;\n    // We should enable debugging dynamic accesses when the static shell\n    // debugging has been enabled and we're also in development mode.\n    const isDebugDynamicAccesses = isDebugStaticShell && routeModule.isDev === true;\n    const isDebugFallbackShell = hasDebugFallbackShellQuery && isRoutePPREnabled;\n    // If we're in minimal mode, then try to get the postponed information from\n    // the request metadata. If available, use it for resuming the postponed\n    // render.\n    const minimalPostponed = isRoutePPREnabled ? initialPostponed : undefined;\n    // If PPR is enabled, and this is a RSC request (but not a prefetch), then\n    // we can use this fact to only generate the flight data for the request\n    // because we can't cache the HTML (as it's also dynamic).\n    const isDynamicRSCRequest = isRoutePPREnabled && isRSCRequest && !isPrefetchRSCRequest;\n    // Need to read this before it's stripped by stripFlightHeaders. We don't\n    // need to transfer it to the request meta because it's only read\n    // within this function; the static segment data should have already been\n    // generated, so we will always either return a static response or a 404.\n    const segmentPrefetchHeader = getRequestMeta(req, 'segmentPrefetchRSCRequest');\n    // TODO: investigate existing bug with shouldServeStreamingMetadata always\n    // being true for a revalidate due to modifying the base-server this.renderOpts\n    // when fixing this to correct logic it causes hydration issue since we set\n    // serveStreamingMetadata to true during export\n    let serveStreamingMetadata = !userAgent ? true : shouldServeStreamingMetadata(userAgent, nextConfig.htmlLimitedBots);\n    if (isHtmlBot && isRoutePPREnabled) {\n        isSSG = false;\n        serveStreamingMetadata = false;\n    }\n    // In development, we always want to generate dynamic HTML.\n    let supportsDynamicResponse = // If we're in development, we always support dynamic HTML, unless it's\n    // a data request, in which case we only produce static HTML.\n    routeModule.isDev === true || // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isSSG || // If this request has provided postponed data, it supports dynamic\n    // HTML.\n    typeof initialPostponed === 'string' || // If this is a dynamic RSC request, then this render supports dynamic\n    // HTML (it's dynamic).\n    isDynamicRSCRequest;\n    // When html bots request PPR page, perform the full dynamic rendering.\n    const shouldWaitOnAllReady = isHtmlBot && isRoutePPREnabled;\n    let ssgCacheKey = null;\n    if (!isDraftMode && isSSG && !supportsDynamicResponse && !isPossibleServerAction && !minimalPostponed && !isDynamicRSCRequest) {\n        ssgCacheKey = resolvedPathname;\n    }\n    // the staticPathKey differs from ssgCacheKey since\n    // ssgCacheKey is null in dev since we're always in \"dynamic\"\n    // mode in dev to bypass the cache, but we still need to honor\n    // dynamicParams = false in dev mode\n    let staticPathKey = ssgCacheKey;\n    if (!staticPathKey && routeModule.isDev) {\n        staticPathKey = resolvedPathname;\n    }\n    // If this is a request for an app path that should be statically generated\n    // and we aren't in the edge runtime, strip the flight headers so it will\n    // generate the static response.\n    if (!routeModule.isDev && !isDraftMode && isSSG && isRSCRequest && !isDynamicRSCRequest) {\n        stripFlightHeaders(req.headers);\n    }\n    const ComponentMod = {\n        ...entryBase,\n        tree,\n        pages,\n        GlobalError,\n        handler,\n        routeModule,\n        __next_app__\n    };\n    // Before rendering (which initializes component tree modules), we have to\n    // set the reference manifests to our global store so Server Action's\n    // encryption util can access to them at the top level of the page module.\n    if (serverActionsManifest && clientReferenceManifest) {\n        setReferenceManifestsSingleton({\n            page: srcPage,\n            clientReferenceManifest,\n            serverActionsManifest,\n            serverModuleMap: createServerModuleMap({\n                serverActionsManifest\n            })\n        });\n    }\n    const method = req.method || 'GET';\n    const tracer = getTracer();\n    const activeSpan = tracer.getActiveScopeSpan();\n    try {\n        const varyHeader = routeModule.getVaryHeader(resolvedPathname, interceptionRoutePatterns);\n        res.setHeader('Vary', varyHeader);\n        const invokeRouteModule = async (span, context)=>{\n            const nextReq = new NodeNextRequest(req);\n            const nextRes = new NodeNextResponse(res);\n            // TODO: adapt for putting the RDC inside the postponed data\n            // If we're in dev, and this isn't a prefetch or a server action,\n            // we should seed the resume data cache.\n            if (process.env.NODE_ENV === 'development') {\n                if (nextConfig.experimental.cacheComponents && !isPrefetchRSCRequest && !context.renderOpts.isPossibleServerAction) {\n                    const warmup = await routeModule.warmup(nextReq, nextRes, context);\n                    // If the warmup is successful, we should use the resume data\n                    // cache from the warmup.\n                    if (warmup.metadata.renderResumeDataCache) {\n                        context.renderOpts.renderResumeDataCache = warmup.metadata.renderResumeDataCache;\n                    }\n                }\n            }\n            return routeModule.render(nextReq, nextRes, context).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${req.url}`);\n                }\n            });\n        };\n        const doRender = async ({ span, postponed, fallbackRouteParams })=>{\n            const context = {\n                query,\n                params,\n                page: normalizedSrcPage,\n                sharedContext: {\n                    buildId\n                },\n                serverComponentsHmrCache: getRequestMeta(req, 'serverComponentsHmrCache'),\n                fallbackRouteParams,\n                renderOpts: {\n                    App: ()=>null,\n                    Document: ()=>null,\n                    pageConfig: {},\n                    ComponentMod,\n                    Component: interopDefault(ComponentMod),\n                    params,\n                    routeModule,\n                    page: srcPage,\n                    postponed,\n                    shouldWaitOnAllReady,\n                    serveStreamingMetadata,\n                    supportsDynamicResponse: typeof postponed === 'string' || supportsDynamicResponse,\n                    buildManifest,\n                    nextFontManifest,\n                    reactLoadableManifest,\n                    subresourceIntegrityManifest,\n                    serverActionsManifest,\n                    clientReferenceManifest,\n                    setIsrStatus: routerServerContext == null ? void 0 : routerServerContext.setIsrStatus,\n                    dir: process.env.NEXT_RUNTIME === 'nodejs' ? require('path').join(/* turbopackIgnore: true */ process.cwd(), routeModule.relativeProjectDir) : `${process.cwd()}/${routeModule.relativeProjectDir}`,\n                    isDraftMode,\n                    isRevalidate: isSSG && !postponed && !isDynamicRSCRequest,\n                    botType,\n                    isOnDemandRevalidate,\n                    isPossibleServerAction,\n                    assetPrefix: nextConfig.assetPrefix,\n                    nextConfigOutput: nextConfig.output,\n                    crossOrigin: nextConfig.crossOrigin,\n                    trailingSlash: nextConfig.trailingSlash,\n                    previewProps: prerenderManifest.preview,\n                    deploymentId: nextConfig.deploymentId,\n                    enableTainting: nextConfig.experimental.taint,\n                    htmlLimitedBots: nextConfig.htmlLimitedBots,\n                    devtoolSegmentExplorer: nextConfig.experimental.devtoolSegmentExplorer,\n                    reactMaxHeadersLength: nextConfig.reactMaxHeadersLength,\n                    multiZoneDraftMode,\n                    incrementalCache: getRequestMeta(req, 'incrementalCache'),\n                    cacheLifeProfiles: nextConfig.experimental.cacheLife,\n                    basePath: nextConfig.basePath,\n                    serverActions: nextConfig.experimental.serverActions,\n                    ...isDebugStaticShell || isDebugDynamicAccesses ? {\n                        nextExport: true,\n                        supportsDynamicResponse: false,\n                        isStaticGeneration: true,\n                        isRevalidate: true,\n                        isDebugDynamicAccesses: isDebugDynamicAccesses\n                    } : {},\n                    experimental: {\n                        isRoutePPREnabled,\n                        expireTime: nextConfig.expireTime,\n                        staleTimes: nextConfig.experimental.staleTimes,\n                        cacheComponents: Boolean(nextConfig.experimental.cacheComponents),\n                        clientSegmentCache: Boolean(nextConfig.experimental.clientSegmentCache),\n                        clientParamParsing: Boolean(nextConfig.experimental.clientParamParsing),\n                        dynamicOnHover: Boolean(nextConfig.experimental.dynamicOnHover),\n                        inlineCss: Boolean(nextConfig.experimental.inlineCss),\n                        authInterrupts: Boolean(nextConfig.experimental.authInterrupts),\n                        clientTraceMetadata: nextConfig.experimental.clientTraceMetadata || []\n                    },\n                    waitUntil: ctx.waitUntil,\n                    onClose: (cb)=>{\n                        res.on('close', cb);\n                    },\n                    onAfterTaskError: ()=>{},\n                    onInstrumentationRequestError: (error, _request, errorContext)=>routeModule.onRequestError(req, error, errorContext, routerServerContext),\n                    err: getRequestMeta(req, 'invokeError'),\n                    dev: routeModule.isDev\n                }\n            };\n            const result = await invokeRouteModule(span, context);\n            const { metadata } = result;\n            const { cacheControl, headers = {}, // Add any fetch tags that were on the page to the response headers.\n            fetchTags: cacheTags } = metadata;\n            if (cacheTags) {\n                headers[NEXT_CACHE_TAGS_HEADER] = cacheTags;\n            }\n            // Pull any fetch metrics from the render onto the request.\n            ;\n            req.fetchMetrics = metadata.fetchMetrics;\n            // we don't throw static to dynamic errors in dev as isSSG\n            // is a best guess in dev since we don't have the prerender pass\n            // to know whether the path is actually static or not\n            if (isSSG && (cacheControl == null ? void 0 : cacheControl.revalidate) === 0 && !routeModule.isDev && !isRoutePPREnabled) {\n                const staticBailoutInfo = metadata.staticBailoutInfo;\n                const err = Object.defineProperty(new Error(`Page changed from static to dynamic at runtime ${resolvedPathname}${(staticBailoutInfo == null ? void 0 : staticBailoutInfo.description) ? `, reason: ${staticBailoutInfo.description}` : ``}` + `\\nsee more here https://nextjs.org/docs/messages/app-static-to-dynamic-error`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E132\",\n                    enumerable: false,\n                    configurable: true\n                });\n                if (staticBailoutInfo == null ? void 0 : staticBailoutInfo.stack) {\n                    const stack = staticBailoutInfo.stack;\n                    err.stack = err.message + stack.substring(stack.indexOf('\\n'));\n                }\n                throw err;\n            }\n            return {\n                value: {\n                    kind: CachedRouteKind.APP_PAGE,\n                    html: result,\n                    headers,\n                    rscData: metadata.flightData,\n                    postponed: metadata.postponed,\n                    status: metadata.statusCode,\n                    segmentData: metadata.segmentData\n                },\n                cacheControl\n            };\n        };\n        const responseGenerator = async ({ hasResolved, previousCacheEntry, isRevalidating, span })=>{\n            const isProduction = routeModule.isDev === false;\n            const didRespond = hasResolved || res.writableEnded;\n            // skip on-demand revalidate if cache is not present and\n            // revalidate-if-generated is set\n            if (isOnDemandRevalidate && revalidateOnlyGenerated && !previousCacheEntry && !minimalMode) {\n                if (routerServerContext == null ? void 0 : routerServerContext.render404) {\n                    await routerServerContext.render404(req, res);\n                } else {\n                    res.statusCode = 404;\n                    res.end('This page could not be found');\n                }\n                return null;\n            }\n            let fallbackMode;\n            if (prerenderInfo) {\n                fallbackMode = parseFallbackField(prerenderInfo.fallback);\n            }\n            // When serving a HTML bot request, we want to serve a blocking render and\n            // not the prerendered page. This ensures that the correct content is served\n            // to the bot in the head.\n            if (fallbackMode === FallbackMode.PRERENDER && isBot(userAgent)) {\n                if (!isRoutePPREnabled || isHtmlBot) {\n                    fallbackMode = FallbackMode.BLOCKING_STATIC_RENDER;\n                }\n            }\n            if ((previousCacheEntry == null ? void 0 : previousCacheEntry.isStale) === -1) {\n                isOnDemandRevalidate = true;\n            }\n            // TODO: adapt for PPR\n            // only allow on-demand revalidate for fallback: true/blocking\n            // or for prerendered fallback: false paths\n            if (isOnDemandRevalidate && (fallbackMode !== FallbackMode.NOT_FOUND || previousCacheEntry)) {\n                fallbackMode = FallbackMode.BLOCKING_STATIC_RENDER;\n            }\n            if (!minimalMode && fallbackMode !== FallbackMode.BLOCKING_STATIC_RENDER && staticPathKey && !didRespond && !isDraftMode && pageIsDynamic && (isProduction || !isPrerendered)) {\n                // if the page has dynamicParams: false and this pathname wasn't\n                // prerendered trigger the no fallback handling\n                if (// In development, fall through to render to handle missing\n                // getStaticPaths.\n                (isProduction || prerenderInfo) && // When fallback isn't present, abort this render so we 404\n                fallbackMode === FallbackMode.NOT_FOUND) {\n                    throw new NoFallbackError();\n                }\n                let fallbackResponse;\n                if (isRoutePPREnabled && !isRSCRequest) {\n                    const cacheKey = typeof (prerenderInfo == null ? void 0 : prerenderInfo.fallback) === 'string' ? prerenderInfo.fallback : isProduction ? normalizedSrcPage : null;\n                    // We use the response cache here to handle the revalidation and\n                    // management of the fallback shell.\n                    fallbackResponse = await routeModule.handleResponse({\n                        cacheKey,\n                        req,\n                        nextConfig,\n                        routeKind: RouteKind.APP_PAGE,\n                        isFallback: true,\n                        prerenderManifest,\n                        isRoutePPREnabled,\n                        responseGenerator: async ()=>doRender({\n                                span,\n                                // We pass `undefined` as rendering a fallback isn't resumed\n                                // here.\n                                postponed: undefined,\n                                fallbackRouteParams: // If we're in production or we're debugging the fallback\n                                // shell then we should postpone when dynamic params are\n                                // accessed.\n                                isProduction || isDebugFallbackShell ? getFallbackRouteParams(normalizedSrcPage) : null\n                            }),\n                        waitUntil: ctx.waitUntil\n                    });\n                    // If the fallback response was set to null, then we should return null.\n                    if (fallbackResponse === null) return null;\n                    // Otherwise, if we did get a fallback response, we should return it.\n                    if (fallbackResponse) {\n                        // Remove the cache control from the response to prevent it from being\n                        // used in the surrounding cache.\n                        delete fallbackResponse.cacheControl;\n                        return fallbackResponse;\n                    }\n                }\n            }\n            // Only requests that aren't revalidating can be resumed. If we have the\n            // minimal postponed data, then we should resume the render with it.\n            const postponed = !isOnDemandRevalidate && !isRevalidating && minimalPostponed ? minimalPostponed : undefined;\n            // When we're in minimal mode, if we're trying to debug the static shell,\n            // we should just return nothing instead of resuming the dynamic render.\n            if ((isDebugStaticShell || isDebugDynamicAccesses) && typeof postponed !== 'undefined') {\n                return {\n                    cacheControl: {\n                        revalidate: 1,\n                        expire: undefined\n                    },\n                    value: {\n                        kind: CachedRouteKind.PAGES,\n                        html: RenderResult.EMPTY,\n                        pageData: {},\n                        headers: undefined,\n                        status: undefined\n                    }\n                };\n            }\n            // If this is a dynamic route with PPR enabled and the default route\n            // matches were set, then we should pass the fallback route params to\n            // the renderer as this is a fallback revalidation request.\n            const fallbackRouteParams = pageIsDynamic && isRoutePPREnabled && (getRequestMeta(req, 'renderFallbackShell') || isDebugFallbackShell) ? getFallbackRouteParams(pathname) : null;\n            // Perform the render.\n            return doRender({\n                span,\n                postponed,\n                fallbackRouteParams\n            });\n        };\n        const handleResponse = async (span)=>{\n            var _cacheEntry_value, _cachedData_headers;\n            const cacheEntry = await routeModule.handleResponse({\n                cacheKey: ssgCacheKey,\n                responseGenerator: (c)=>responseGenerator({\n                        span,\n                        ...c\n                    }),\n                routeKind: RouteKind.APP_PAGE,\n                isOnDemandRevalidate,\n                isRoutePPREnabled,\n                req,\n                nextConfig,\n                prerenderManifest,\n                waitUntil: ctx.waitUntil\n            });\n            if (isDraftMode) {\n                res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');\n            }\n            // In dev, we should not cache pages for any reason.\n            if (routeModule.isDev) {\n                res.setHeader('Cache-Control', 'no-store, must-revalidate');\n            }\n            if (!cacheEntry) {\n                if (ssgCacheKey) {\n                    // A cache entry might not be generated if a response is written\n                    // in `getInitialProps` or `getServerSideProps`, but those shouldn't\n                    // have a cache key. If we do have a cache key but we don't end up\n                    // with a cache entry, then either Next.js or the application has a\n                    // bug that needs fixing.\n                    throw Object.defineProperty(new Error('invariant: cache entry required but not generated'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E62\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                return null;\n            }\n            if (((_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) !== CachedRouteKind.APP_PAGE) {\n                var _cacheEntry_value1;\n                throw Object.defineProperty(new Error(`Invariant app-page handler received invalid cache entry ${(_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E707\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            const didPostpone = typeof cacheEntry.value.postponed === 'string';\n            if (isSSG && // We don't want to send a cache header for requests that contain dynamic\n            // data. If this is a Dynamic RSC request or wasn't a Prefetch RSC\n            // request, then we should set the cache header.\n            !isDynamicRSCRequest && (!didPostpone || isPrefetchRSCRequest)) {\n                if (!minimalMode) {\n                    // set x-nextjs-cache header to match the header\n                    // we set for the image-optimizer\n                    res.setHeader('x-nextjs-cache', isOnDemandRevalidate ? 'REVALIDATED' : cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT');\n                }\n                // Set a header used by the client router to signal the response is static\n                // and should respect the `static` cache staleTime value.\n                res.setHeader(NEXT_IS_PRERENDER_HEADER, '1');\n            }\n            const { value: cachedData } = cacheEntry;\n            // Coerce the cache control parameter from the render.\n            let cacheControl;\n            // If this is a resume request in minimal mode it is streamed with dynamic\n            // content and should not be cached.\n            if (minimalPostponed) {\n                cacheControl = {\n                    revalidate: 0,\n                    expire: undefined\n                };\n            } else if (minimalMode && isRSCRequest && !isPrefetchRSCRequest && isRoutePPREnabled) {\n                cacheControl = {\n                    revalidate: 0,\n                    expire: undefined\n                };\n            } else if (!routeModule.isDev) {\n                // If this is a preview mode request, we shouldn't cache it\n                if (isDraftMode) {\n                    cacheControl = {\n                        revalidate: 0,\n                        expire: undefined\n                    };\n                } else if (!isSSG) {\n                    if (!res.getHeader('Cache-Control')) {\n                        cacheControl = {\n                            revalidate: 0,\n                            expire: undefined\n                        };\n                    }\n                } else if (cacheEntry.cacheControl) {\n                    // If the cache entry has a cache control with a revalidate value that's\n                    // a number, use it.\n                    if (typeof cacheEntry.cacheControl.revalidate === 'number') {\n                        var _cacheEntry_cacheControl;\n                        if (cacheEntry.cacheControl.revalidate < 1) {\n                            throw Object.defineProperty(new Error(`Invalid revalidate configuration provided: ${cacheEntry.cacheControl.revalidate} < 1`), \"__NEXT_ERROR_CODE\", {\n                                value: \"E22\",\n                                enumerable: false,\n                                configurable: true\n                            });\n                        }\n                        cacheControl = {\n                            revalidate: cacheEntry.cacheControl.revalidate,\n                            expire: ((_cacheEntry_cacheControl = cacheEntry.cacheControl) == null ? void 0 : _cacheEntry_cacheControl.expire) ?? nextConfig.expireTime\n                        };\n                    } else {\n                        cacheControl = {\n                            revalidate: CACHE_ONE_YEAR,\n                            expire: undefined\n                        };\n                    }\n                }\n            }\n            cacheEntry.cacheControl = cacheControl;\n            if (typeof segmentPrefetchHeader === 'string' && (cachedData == null ? void 0 : cachedData.kind) === CachedRouteKind.APP_PAGE && cachedData.segmentData) {\n                var _cachedData_headers1;\n                // This is a prefetch request issued by the client Segment Cache. These\n                // should never reach the application layer (lambda). We should either\n                // respond from the cache (HIT) or respond with 204 No Content (MISS).\n                // Set a header to indicate that PPR is enabled for this route. This\n                // lets the client distinguish between a regular cache miss and a cache\n                // miss due to PPR being disabled. In other contexts this header is used\n                // to indicate that the response contains dynamic data, but here we're\n                // only using it to indicate that the feature is enabled — the segment\n                // response itself contains whether the data is dynamic.\n                res.setHeader(NEXT_DID_POSTPONE_HEADER, '2');\n                // Add the cache tags header to the response if it exists and we're in\n                // minimal mode while rendering a static page.\n                const tags = (_cachedData_headers1 = cachedData.headers) == null ? void 0 : _cachedData_headers1[NEXT_CACHE_TAGS_HEADER];\n                if (minimalMode && isSSG && tags && typeof tags === 'string') {\n                    res.setHeader(NEXT_CACHE_TAGS_HEADER, tags);\n                }\n                const matchedSegment = cachedData.segmentData.get(segmentPrefetchHeader);\n                if (matchedSegment !== undefined) {\n                    // Cache hit\n                    return sendRenderResult({\n                        req,\n                        res,\n                        generateEtags: nextConfig.generateEtags,\n                        poweredByHeader: nextConfig.poweredByHeader,\n                        result: RenderResult.fromStatic(matchedSegment, RSC_CONTENT_TYPE_HEADER),\n                        cacheControl: cacheEntry.cacheControl\n                    });\n                }\n                // Cache miss. Either a cache entry for this route has not been generated\n                // (which technically should not be possible when PPR is enabled, because\n                // at a minimum there should always be a fallback entry) or there's no\n                // match for the requested segment. Respond with a 204 No Content. We\n                // don't bother to respond with 404, because these requests are only\n                // issued as part of a prefetch.\n                res.statusCode = 204;\n                return sendRenderResult({\n                    req,\n                    res,\n                    generateEtags: nextConfig.generateEtags,\n                    poweredByHeader: nextConfig.poweredByHeader,\n                    result: RenderResult.EMPTY,\n                    cacheControl: cacheEntry.cacheControl\n                });\n            }\n            // If there's a callback for `onCacheEntry`, call it with the cache entry\n            // and the revalidate options.\n            const onCacheEntry = getRequestMeta(req, 'onCacheEntry');\n            if (onCacheEntry) {\n                const finished = await onCacheEntry({\n                    ...cacheEntry,\n                    // TODO: remove this when upstream doesn't\n                    // always expect this value to be \"PAGE\"\n                    value: {\n                        ...cacheEntry.value,\n                        kind: 'PAGE'\n                    }\n                }, {\n                    url: getRequestMeta(req, 'initURL')\n                });\n                if (finished) {\n                    // TODO: maybe we have to end the request?\n                    return null;\n                }\n            }\n            // If the request has a postponed state and it's a resume request we\n            // should error.\n            if (didPostpone && minimalPostponed) {\n                throw Object.defineProperty(new Error('Invariant: postponed state should not be present on a resume request'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E396\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            if (cachedData.headers) {\n                const headers = {\n                    ...cachedData.headers\n                };\n                if (!minimalMode || !isSSG) {\n                    delete headers[NEXT_CACHE_TAGS_HEADER];\n                }\n                for (let [key, value] of Object.entries(headers)){\n                    if (typeof value === 'undefined') continue;\n                    if (Array.isArray(value)) {\n                        for (const v of value){\n                            res.appendHeader(key, v);\n                        }\n                    } else if (typeof value === 'number') {\n                        value = value.toString();\n                        res.appendHeader(key, value);\n                    } else {\n                        res.appendHeader(key, value);\n                    }\n                }\n            }\n            // Add the cache tags header to the response if it exists and we're in\n            // minimal mode while rendering a static page.\n            const tags = (_cachedData_headers = cachedData.headers) == null ? void 0 : _cachedData_headers[NEXT_CACHE_TAGS_HEADER];\n            if (minimalMode && isSSG && tags && typeof tags === 'string') {\n                res.setHeader(NEXT_CACHE_TAGS_HEADER, tags);\n            }\n            // If the request is a data request, then we shouldn't set the status code\n            // from the response because it should always be 200. This should be gated\n            // behind the experimental PPR flag.\n            if (cachedData.status && (!isRSCRequest || !isRoutePPREnabled)) {\n                res.statusCode = cachedData.status;\n            }\n            // Redirect information is encoded in RSC payload, so we don't need to use redirect status codes\n            if (!minimalMode && cachedData.status && RedirectStatusCode[cachedData.status] && isRSCRequest) {\n                res.statusCode = 200;\n            }\n            // Mark that the request did postpone.\n            if (didPostpone) {\n                res.setHeader(NEXT_DID_POSTPONE_HEADER, '1');\n            }\n            // we don't go through this block when preview mode is true\n            // as preview mode is a dynamic request (bypasses cache) and doesn't\n            // generate both HTML and payloads in the same request so continue to just\n            // return the generated payload\n            if (isRSCRequest && !isDraftMode) {\n                // If this is a dynamic RSC request, then stream the response.\n                if (typeof cachedData.rscData === 'undefined') {\n                    if (cachedData.postponed) {\n                        throw Object.defineProperty(new Error('Invariant: Expected postponed to be undefined'), \"__NEXT_ERROR_CODE\", {\n                            value: \"E372\",\n                            enumerable: false,\n                            configurable: true\n                        });\n                    }\n                    return sendRenderResult({\n                        req,\n                        res,\n                        generateEtags: nextConfig.generateEtags,\n                        poweredByHeader: nextConfig.poweredByHeader,\n                        result: cachedData.html,\n                        // Dynamic RSC responses cannot be cached, even if they're\n                        // configured with `force-static` because we have no way of\n                        // distinguishing between `force-static` and pages that have no\n                        // postponed state.\n                        // TODO: distinguish `force-static` from pages with no postponed state (static)\n                        cacheControl: isDynamicRSCRequest ? {\n                            revalidate: 0,\n                            expire: undefined\n                        } : cacheEntry.cacheControl\n                    });\n                }\n                // As this isn't a prefetch request, we should serve the static flight\n                // data.\n                return sendRenderResult({\n                    req,\n                    res,\n                    generateEtags: nextConfig.generateEtags,\n                    poweredByHeader: nextConfig.poweredByHeader,\n                    result: RenderResult.fromStatic(cachedData.rscData, RSC_CONTENT_TYPE_HEADER),\n                    cacheControl: cacheEntry.cacheControl\n                });\n            }\n            // This is a request for HTML data.\n            let body = cachedData.html;\n            // If there's no postponed state, we should just serve the HTML. This\n            // should also be the case for a resume request because it's completed\n            // as a server render (rather than a static render).\n            if (!didPostpone || minimalMode || isRSCRequest) {\n                // If we're in test mode, we should add a sentinel chunk to the response\n                // that's between the static and dynamic parts so we can compare the\n                // chunks and add assertions.\n                if (process.env.__NEXT_TEST_MODE && minimalMode && isRoutePPREnabled && body.contentType === HTML_CONTENT_TYPE_HEADER) {\n                    // As we're in minimal mode, the static part would have already been\n                    // streamed first. The only part that this streams is the dynamic part\n                    // so we should FIRST stream the sentinel and THEN the dynamic part.\n                    body.unshift(createPPRBoundarySentinel());\n                }\n                return sendRenderResult({\n                    req,\n                    res,\n                    generateEtags: nextConfig.generateEtags,\n                    poweredByHeader: nextConfig.poweredByHeader,\n                    result: body,\n                    cacheControl: cacheEntry.cacheControl\n                });\n            }\n            // If we're debugging the static shell or the dynamic API accesses, we\n            // should just serve the HTML without resuming the render. The returned\n            // HTML will be the static shell so all the Dynamic API's will be used\n            // during static generation.\n            if (isDebugStaticShell || isDebugDynamicAccesses) {\n                // Since we're not resuming the render, we need to at least add the\n                // closing body and html tags to create valid HTML.\n                body.push(new ReadableStream({\n                    start (controller) {\n                        controller.enqueue(ENCODED_TAGS.CLOSED.BODY_AND_HTML);\n                        controller.close();\n                    }\n                }));\n                return sendRenderResult({\n                    req,\n                    res,\n                    generateEtags: nextConfig.generateEtags,\n                    poweredByHeader: nextConfig.poweredByHeader,\n                    result: body,\n                    cacheControl: {\n                        revalidate: 0,\n                        expire: undefined\n                    }\n                });\n            }\n            // If we're in test mode, we should add a sentinel chunk to the response\n            // that's between the static and dynamic parts so we can compare the\n            // chunks and add assertions.\n            if (process.env.__NEXT_TEST_MODE) {\n                body.push(createPPRBoundarySentinel());\n            }\n            // This request has postponed, so let's create a new transformer that the\n            // dynamic data can pipe to that will attach the dynamic data to the end\n            // of the response.\n            const transformer = new TransformStream();\n            body.push(transformer.readable);\n            // Perform the render again, but this time, provide the postponed state.\n            // We don't await because we want the result to start streaming now, and\n            // we've already chained the transformer's readable to the render result.\n            doRender({\n                span,\n                postponed: cachedData.postponed,\n                // This is a resume render, not a fallback render, so we don't need to\n                // set this.\n                fallbackRouteParams: null\n            }).then(async (result)=>{\n                var _result_value;\n                if (!result) {\n                    throw Object.defineProperty(new Error('Invariant: expected a result to be returned'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E463\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                if (((_result_value = result.value) == null ? void 0 : _result_value.kind) !== CachedRouteKind.APP_PAGE) {\n                    var _result_value1;\n                    throw Object.defineProperty(new Error(`Invariant: expected a page response, got ${(_result_value1 = result.value) == null ? void 0 : _result_value1.kind}`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E305\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                // Pipe the resume result to the transformer.\n                await result.value.html.pipeTo(transformer.writable);\n            }).catch((err)=>{\n                // An error occurred during piping or preparing the render, abort\n                // the transformers writer so we can terminate the stream.\n                transformer.writable.abort(err).catch((e)=>{\n                    console.error(\"couldn't abort transformer\", e);\n                });\n            });\n            return sendRenderResult({\n                req,\n                res,\n                generateEtags: nextConfig.generateEtags,\n                poweredByHeader: nextConfig.poweredByHeader,\n                result: body,\n                // We don't want to cache the response if it has postponed data because\n                // the response being sent to the client it's dynamic parts are streamed\n                // to the client on the same request.\n                cacheControl: {\n                    revalidate: 0,\n                    expire: undefined\n                }\n            });\n        };\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await handleResponse(activeSpan);\n        } else {\n            return await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${req.url}`,\n                    kind: SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, handleResponse));\n        }\n    } catch (err) {\n        // if we aren't wrapped by base-server handle here\n        if (!activeSpan && !(err instanceof NoFallbackError)) {\n            await routeModule.onRequestError(req, err, {\n                routerKind: 'App Router',\n                routePath: srcPage,\n                routeType: 'render',\n                revalidateReason: getRevalidateReason({\n                    isRevalidate: isSSG,\n                    isOnDemandRevalidate\n                })\n            }, routerServerContext);\n        }\n        // rethrow so that we can handle serving error page\n        throw err;\n    }\n}\n// TODO: omit this from production builds, only test builds should include it\n/**\n * Creates a readable stream that emits a PPR boundary sentinel.\n *\n * @returns A readable stream that emits a PPR boundary sentinel.\n */ function createPPRBoundarySentinel() {\n    return new ReadableStream({\n        start (controller) {\n            controller.enqueue(new TextEncoder().encode('<!-- PPR_BOUNDARY_SENTINEL -->'));\n            controller.close();\n        }\n    });\n}\n\n//# sourceMappingURL=app-page.js.map\n"],"names":["metadata","title","description","keywords","authors","name","url","creator","publisher","robots","metadataBase","URL","alternates","canonical","openGraph","type","siteName","locale","images","width","height","alt","twitter","card","other","RootLayout","_jsxs","html","lang","_jsx","head","script","dangerouslySetInnerHTML","__html","JSON","stringify","body","className","geistSans","geistMono","children"],"sourceRoot":""}